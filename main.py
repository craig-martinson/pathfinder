import pygame
import random

from astar import find_path_astar
from dijkstra import find_path_dijkstra

# Define the constants

GRID_WIDTH = 400
GRID_HEIGHT = 400
CELL_WIDTH = 5
CELL_HEIGHT = 5

# Define the colors
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
YELLOW = (255, 255, 0)
PURPLE = (128, 0, 128)
ORANGE = (255, 165, 0)


def random_empty_point(grid):
    empty_points = []
    for i in range(len(grid)):
        for j in range(len(grid[i])):
            if grid[i][j] == 0:
                empty_points.append((i, j))
    if len(empty_points) == 0:
        return None
    else:
        return random.choice(empty_points)


def generate_rectangles(
    x,
    y,
    width,
    height,
    *,
    max_rectangles=64,
    alignment_grid=10,
    min_width_multiple=1,
    max_width_multiple=2,
    min_height_multiple=1,
    max_height_multiple=2,
    border_multiple=1
):
    rectangles = []

    # Generate the rectangles
    for i in range(max_rectangles):
        rect_x = random.randint(0, width - 1)
        rect_y = random.randint(0, height - 1)

        # Align rectangle origin to coarse grid, realtive to parent origin
        rect_x = x + (rect_x + (alignment_grid // 2)) // alignment_grid * alignment_grid
        rect_y = y + (rect_y + (alignment_grid // 2)) // alignment_grid * alignment_grid

        # Generate rectangle
        w = random.randint(min_width_multiple, max_width_multiple) * alignment_grid
        h = random.randint(min_height_multiple, max_height_multiple) * alignment_grid

        # Ignore overlaping rects or rects that extend pass the border
        rect = [rect_x, rect_y, w, h]
        border = alignment_grid * border_multiple
        if is_rect_inside(
            rect, [x + border, y + border, width - 2 * border, height - 2 * border]
        ):
            if not overlaps(rect, rectangles) and not touches(rect, rectangles):
                rectangles.append(rect)

    return rectangles


def overlaps(rect1, rectangles):
    for rect2 in rectangles:
        if (
            rect1[0] < rect2[0] + rect2[2]
            and rect1[0] + rect1[2] > rect2[0]
            and rect1[1] < rect2[1] + rect2[3]
            and rect1[1] + rect1[3] > rect2[1]
        ):
            return True
    return False


def touches(rect1, rectangles):
    for rect2 in rectangles:
        if (
            rect1[0] < rect2[0] + rect2[2] + 1
            and rect1[0] + rect1[2] > rect2[0] - 1
            and rect1[1] < rect2[1] + rect2[3] + 1
            and rect1[1] + rect1[3] > rect2[1] - 1
        ):
            return True
    return False


def is_rect_inside(rect1, rect2):
    return (
        rect1[0] >= rect2[0]
        and rect1[0] + rect1[2] <= rect2[0] + rect2[2]
        and rect1[1] >= rect2[1]
        and rect1[1] + rect1[3] <= rect2[1] + rect2[3]
    )


# Define the function to rasterize rectangles in an array
def rasterize_rectangles(rectangles, grid):
    for rect in rectangles:
        x, y, w, h = rect
        for i in range(y, y + h):
            for j in range(x, x + w):
                if i >= 0 and i < len(grid) and j >= 0 and j < len(grid[0]):
                    grid[i][j] = 1
    return grid


def print_grid(grid):
    for row in grid:
        print(" ".join(str(cell) for cell in row))

def remove_corners(path, grid):
    if len(path) < 3:
        return path
    new_path = [path[0]]
    for i in range(2, len(path)):
        x1, y1 = path[i - 2]
        x2, y2 = path[i - 1]
        x3, y3 = path[i]
        if (x1 == x3 and y1 != y3) or (x1 != x3 and y1 == y3):
            # The cells are aligned, no corner
            new_path.append(path[i - 1])
        elif grid[x2][y3] == 0:
            # The cells are not aligned, but there is no obstacle
            new_path.append(path[i - 1])
    new_path.append(path[-1])
    return new_path


def minimize_corners_90(path):
    """
    Given a path generated by A-star algorithm, returns a modified path that minimizes the number of corners while using only horizontal or vertical segments.
    """
    # If the path has less than three points, there is no corner to eliminate.
    if len(path) < 3:
        return path

    # Initialize the new path with the first two points from the original path.
    new_path = [path[0], path[1]]

    # Iterate over the remaining points in the path.
    for i in range(2, len(path)):
        # Check if the current point forms a straight line with the previous two points.
        if (new_path[-1][0] - new_path[-2][0]) * (path[i][1] - new_path[-2][1]) == (
            new_path[-1][1] - new_path[-2][1]
        ) * (path[i][0] - new_path[-2][0]):
            # If it does, skip adding the current point to the new path.
            continue
        # Otherwise, check if a 90 degree turn is possible.
        if new_path[-1][0] == new_path[-2][0]:
            if path[i][0] == new_path[-1][0]:
                # If the current point is on the same vertical line, skip adding the intermediate point.
                continue
            else:
                # Add an intermediate point to force a horizontal turn.
                int_point = (path[i][0], new_path[-1][1])
        elif new_path[-1][1] == new_path[-2][1]:
            if path[i][1] == new_path[-1][1]:
                # If the current point is on the same horizontal line, skip adding the intermediate point.
                continue
            else:
                # Add an intermediate point to force a vertical turn.
                int_point = (new_path[-1][0], path[i][1])
        else:
            # This should not happen if the path is valid.
            raise ValueError("Invalid path")

        # Add the intermediate point and the current point to the new path.
        new_path.append(int_point)
        new_path.append(path[i])

    return new_path


def print_path(path):
    if path:
        for row in path:
            print(" ".join(str(cell) for cell in row))
    else:
        print("Empty path")

def inititalise_map(grid):
    # Generate parent rectangles
    parent_rects = generate_rectangles(
        0,
        0,
        GRID_WIDTH,
        GRID_HEIGHT,
        max_rectangles=100,
        alignment_grid=8,
        min_width_multiple=4,
        max_width_multiple=8,
        min_height_multiple=4,
        max_height_multiple=8,
    )

    # Generate the child rectangles
    all_rectangles = []

    for rect in parent_rects:
        x, y, w, h = rect

        rects = generate_rectangles(
            x,
            y,
            w,
            h,
            max_rectangles=100,
            alignment_grid=2,
            min_width_multiple=2,
            max_width_multiple=4,
            min_height_multiple=2,
            max_height_multiple=4,
        )

        # Keep track of all rects for rendering
        for rect in rects:
            all_rectangles.append(rect)

    return parent_rects, all_rectangles

def draw_path(cell_width, cell_height, path, screen, color, pan_x, pan_y, zoom):
    if path:
        for i in range(len(path) - 1):
            row1, col1 = path[i]
            row2, col2 = path[i + 1]

            pygame.draw.line(
                screen,
                color,
                [
                    pan_x + (col1 * cell_width + cell_width // 2) * zoom,
                    pan_y + (row1 * cell_height + cell_height // 2) * zoom,
                ],
                [
                    pan_x + (col2 * cell_width + cell_width // 2) * zoom,
                    pan_y + (row2 * cell_height + cell_height // 2) * zoom,
                ],
                2,
            )


def draw_rect(cell_width, cell_height, color, screen, rect, pan_x, pan_y, zoom):
    pygame.draw.rect(
        screen,
        color,
        [
            pan_x + (rect[0] * cell_width) * zoom,
            pan_y + (rect[1] * cell_height) * zoom,
            rect[2] * zoom * cell_width,
            rect[3] * zoom * cell_height,
        ],
    )


def draw_circle(cell_width, cell_height, color, screen, start, pan_x, pan_y, zoom):
    x = pan_x + (start[1] * cell_width + cell_width // 2) * zoom
    y = pan_y + (start[0] * cell_height + cell_height // 2) * zoom
    r = max(1, cell_width * zoom)

    if x >= 0 and y >= 0:
        pygame.draw.circle(
            screen,
            color,
            [
                x,
                y,
            ],
            r,
        )


# Initialize pygame
pygame.init()

# get the size of the screen
screen_info = pygame.display.Info()
screen_width, screen_height = screen_info.current_w, screen_info.current_h

# create a fullscreen display with double buffering and vsync
screen_flags = pygame.FULLSCREEN | pygame.SCALED
screen = pygame.display.set_mode((screen_width, screen_height), screen_flags, vsync=1)

# Set the window title
pygame.display.set_caption("Pathfinding Tests")

clock = pygame.time.Clock()

# Set up the initial zoom and pan values
zoom = 1.0
offset = [0, 0]

# Generate the grid
grid = [[0 for col in range(GRID_WIDTH)] for row in range(GRID_HEIGHT)]

parent_rects, all_rects = inititalise_map(grid)
rasterize_rectangles(all_rects, grid)

# Generate the initial path
start = random_empty_point(grid)
end = random_empty_point(grid)

path_a = find_path_astar(start, end, grid)
path_b = find_path_dijkstra(grid, start, end)

# Define the main program loop
done = False
clock = pygame.time.Clock()

while not done:
    # Handle events
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            done = True
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_SPACE:
                # Generate a new path
                start = random_empty_point(grid)
                end = random_empty_point(grid)
                path_a = find_path_astar(start, end, grid)
                path_b = find_path_dijkstra(grid, start, end)
            elif event.key == pygame.K_ESCAPE:
                # Quit
                done = True
        elif event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 4:  # scroll up
                zoom *= 1.1
                # Calculate new offset based on mouse position
                mouse_pos = pygame.mouse.get_pos()
                offset[0] = mouse_pos[0] - (mouse_pos[0] - offset[0]) * 1.1
                offset[1] = mouse_pos[1] - (mouse_pos[1] - offset[1]) * 1.1
            elif event.button == 5:  # scroll down
                zoom /= 1.1
                # Calculate new offset based on mouse position
                mouse_pos = pygame.mouse.get_pos()
                offset[0] = mouse_pos[0] - (mouse_pos[0] - offset[0]) / 1.1
                offset[1] = mouse_pos[1] - (mouse_pos[1] - offset[1]) / 1.1
        elif event.type == pygame.MOUSEMOTION:
            if event.buttons[0]:  # Left button is held down
                offset[0] += event.rel[0]
                offset[1] += event.rel[1]

    # Clear the screen
    screen.fill(BLACK)

    # Draw the parent rectangles
    for rect in parent_rects:
        draw_rect(
            CELL_WIDTH, CELL_HEIGHT, GREEN, screen, rect, offset[0], offset[1], zoom
        )

    # Draw the rectangles
    for rect in all_rects:
        draw_rect(
            CELL_WIDTH, CELL_HEIGHT, WHITE, screen, rect, offset[0], offset[1], zoom
        )

    # Draw the path
    if len(path_a) < len(path_b):
        draw_path(
            CELL_WIDTH, CELL_HEIGHT, path_a, screen, BLUE, offset[0], offset[1], zoom
        )
    else:
        draw_path(
            CELL_WIDTH, CELL_HEIGHT, path_b, screen, PURPLE, offset[0], offset[1], zoom
        )

    # Draw the start and end points
    draw_circle(
        CELL_WIDTH, CELL_HEIGHT, ORANGE, screen, start, offset[0], offset[1], zoom
    )
    draw_circle(CELL_WIDTH, CELL_HEIGHT, RED, screen, end, offset[0], offset[1], zoom)

    pygame.display.update()

# Quit pygame
pygame.quit()
